---
import Layout from '../layouts/Layout.astro';
---

<Layout title="004">
	<div id="webgl"></div>

</Layout>

<style>
	#webgl{
		position: fixed;
		top: 0;
		left: 0;
	}

	.contents{
		position: fixed;
		z-index: 100;
		bottom: 0;
		right: 0;
	}
</style>

<script>
	import * as THREE from 'three';
	import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
	import { gsap } from "gsap";

	// DOM がパースされたことを検出するイベントを設定
	window.addEventListener('DOMContentLoaded', () => {
		// 制御クラスのインスタンスを生成
		const app = new App3();

		Promise.all([app.loadTexture()]).
		then(() => {
			// 初期化
			app.init();
			// 描画
			app.render();
		})
	}, false);

	/**
	 * three.js を効率よく扱うために自家製の制御クラスを定義
	 */
	class App3 {
		/**
		 * カメラ定義のための定数
		 */
		static get CAMERA_PARAM() {
			return {
				// fovy は Field of View Y のことで、縦方向の視野角を意味する
				fovy: 60,
				// 描画する空間のアスペクト比（縦横比）
				aspect: window.innerWidth / window.innerHeight,
				// 描画する空間のニアクリップ面（最近面）
				near: 0.1,
				// 描画する空間のファークリップ面（最遠面）
				far: 20.0,
				// カメラの位置
				x: 0.0,
				y: 2.0,
				z: 10.0,
				// カメラの中止点
				lookAt: new THREE.Vector3(0.0, 0.0, 0.0),
			};
		}
		/**
		 * レンダラー定義のための定数
		 */
		static get RENDERER_PARAM() {
			return {
				// レンダラーが背景をリセットする際に使われる背景色
				clearColor: 0xffffff,
				// レンダラーが描画する領域の横幅
				width: window.innerWidth,
				// レンダラーが描画する領域の縦幅
				height: window.innerHeight,
			};
		}
		/**
		 * ディレクショナルライト定義のための定数
		 */
		static get DIRECTIONAL_LIGHT_PARAM() {
			return {
				color: 0xffffff, // 光の色
				intensity: 1.0,  // 光の強度
				x: 1.0,          // 光の向きを表すベクトルの X 要素
				y: 1.0,          // 光の向きを表すベクトルの Y 要素
				z: 1.0           // 光の向きを表すベクトルの Z 要素
			};
		}
		/**
		 * アンビエントライト定義のための定数
		 */
		static get AMBIENT_LIGHT_PARAM() {
			return {
				color: 0xffffff, // 光の色
				intensity: 0.5,  // 光の強度
			};
		}
		/**
		 * マテリアル定義のための定数
		 */
		static get MATERIAL_PARAM() {
			return {
				color: 0xffffff, // マテリアルの基本色
				side: THREE.DoubleSide, // THREE.FrontSide THREE.BackSide THREE.DoubleSide
			};
		}

		renderer: any;
		scene: any;
		camera: any;
		directionalLight: any;
		ambientLight: any;
		material: any;
		controls: any;
		axesHelper: any;

		isClick: any;
		time: any;

		plane: any;
		texture: any;

		/**
		 * コンストラクタ
		 * @constructor
		 */
		constructor() {
			this.renderer;         // レンダラ
			this.scene;            // シーン
			this.camera;           // カメラ
			this.directionalLight; // ディレクショナルライト
			this.ambientLight;     // アンビエントライト
			this.material;         // マテリアル
			this.controls;         // オービットコントロール
			this.axesHelper;       // 軸ヘルパー

			this.isClick = false; // キーの押下状態を保持するフラグ
			this.time; //経過時間

			this.plane;
			this.texture;

			// 再帰呼び出しのための this 固定
			this.render = this.render.bind(this);

			// リサイズイベント
			window.addEventListener('resize', () => {
				this.renderer.setSize(window.innerWidth, window.innerHeight);
				this.camera.aspect = window.innerWidth / window.innerHeight;
				this.camera.updateProjectionMatrix();
			}, false);
		}

		// texture load
		loadTexture() {
			return new Promise((resolve) => {
				let url;

				if(location.hostname == '127.0.0.1') {
					url = '../../public/world_map.jpg';
				} else {
					url = '../world_map.jpg';
				}

				const loader = new THREE.TextureLoader();

				loader.load(url, (texture) => {
					this.texture = texture;

					// Promise を解決
					resolve();
				});
			});
		}


		/**
		 * 初期化処理
		 */
		init() {
			// レンダラー
			this.renderer = new THREE.WebGLRenderer();
			this.renderer.setClearColor(new THREE.Color(App3.RENDERER_PARAM.clearColor));
			this.renderer.setPixelRatio(window.devicePixelRatio);
			/* this.renderer.outputEncoding = THREE.GammaEncoding; */
			this.renderer.setSize(App3.RENDERER_PARAM.width, App3.RENDERER_PARAM.height);
			const wrapper = document.querySelector('#webgl');
			wrapper.appendChild(this.renderer.domElement);

			// シーン
			this.scene = new THREE.Scene();
			/* this.scene.environment = this.hdr;  */

			// カメラ
			this.camera = new THREE.PerspectiveCamera(
				App3.CAMERA_PARAM.fovy,
				App3.CAMERA_PARAM.aspect,
				App3.CAMERA_PARAM.near,
				App3.CAMERA_PARAM.far,
			);
			this.camera.position.set(
				App3.CAMERA_PARAM.x,
				App3.CAMERA_PARAM.y,
				App3.CAMERA_PARAM.z,
			);
			this.camera.lookAt(App3.CAMERA_PARAM.lookAt);

			// ディレクショナルライト（平行光源）
			this.directionalLight = new THREE.DirectionalLight(
				App3.DIRECTIONAL_LIGHT_PARAM.color,
				App3.DIRECTIONAL_LIGHT_PARAM.intensity
			);
			this.directionalLight.position.set(
				App3.DIRECTIONAL_LIGHT_PARAM.x,
				App3.DIRECTIONAL_LIGHT_PARAM.y,
				App3.DIRECTIONAL_LIGHT_PARAM.z,
			);
			this.scene.add(this.directionalLight);

			// アンビエントライト（環境光）
			this.ambientLight = new THREE.AmbientLight(
				App3.AMBIENT_LIGHT_PARAM.color,
				App3.AMBIENT_LIGHT_PARAM.intensity,
			);
			this.scene.add(this.ambientLight);

			// マテリアル
			this.material = new THREE.MeshStandardMaterial(App3.MATERIAL_PARAM);

			// コントロール
			this.controls = new OrbitControls(this.camera, this.renderer.domElement);

			// タイマー
			this.time = new THREE.Clock();

			// ヘルパー
			const axesBarLength = 5.0;
			this.axesHelper = new THREE.AxesHelper(axesBarLength);
			this.scene.add(this.axesHelper);

			// 処理
			/* const planeGeometry = new THREE.PlaneGeometry(5.0 / window.innerWidth * window.innerWidth, 5.0 / window.innerHeight * window.innerHeight);
			const planeMaterial = new THREE.MeshBasicMaterial({map: this.texture });
			this.plane = new THREE.Mesh(planeGeometry, planeMaterial);
			this.scene.add(this.plane);
			console.log(window.innerWidth, window.innerHeight) */

			const positionCount = 16;
			const rad = 360 / 16 * Math.PI / 180;
			const radius = 3;
			let positionArray = [];
			let planeArray = [];
			// ワールド座標
			const worldPoint = new THREE.Vector3(0.0, 0.0, 0.0);
			// 基準座標
			const initPoint = new THREE.Vector3(1.0, 0.0, 0.0);
			// 回転基準ベクトル
			const vec1 = new THREE.Vector3().subVectors(initPoint, worldPoint).normalize();

			for(let i = 0; i < positionCount; i++){
				let array = [];
				const x = radius * Math.cos(rad * i + 1); 
				array.push(x); 
				const z = radius * Math.sin(rad * i + 1);
				array.push(z);
				positionArray.push(array);
			}

			console.log(positionArray)

			positionArray.forEach((element, index) => {
				const planeGeometry = new THREE.PlaneGeometry(1, 1);
				const planeMaterial = new THREE.MeshBasicMaterial({map: this.texture, side: THREE.DoubleSide });
				planeArray[index] = new THREE.Mesh(planeGeometry, planeMaterial);
				planeArray[index].position.x = element[0];
				planeArray[index].position.z = element[1];

				// 原点→自身の座標から目標のベクトルを求める
				const vec2 = new THREE.Vector3().subVectors(new THREE.Vector3(planeArray[index].position.x, planeArray[index].position.y, planeArray[index].position.z), worldPoint).normalize();
				// 2つのベクトルの直交ベクトルを求める
				const axis = new THREE.Vector3().crossVectors(vec1, vec2).normalize();
				// 内積でコサインを算出
				const cos = vec1.dot(vec2);
				// コサインをラジアンに変換
				const rotateRad = Math.acos(cos);
				// クォータニオンを求める
				const q = new THREE.Quaternion().setFromAxisAngle(axis, rotateRad);
				// クォータニオンをかけて加算させて、回転させる
				planeArray[index].quaternion.premultiply(q);
				// シーンに追加
				this.scene.add(planeArray[index]);
			});
			
		}

		/**
		 * 描画処理
		 */
		render() {
			// 恒常ループの設定
			requestAnimationFrame(this.render);

			// コントロールを更新
			this.controls.update();


			// レンダラーで描画
			this.renderer.render(this.scene, this.camera);
		}
	}

</script>
